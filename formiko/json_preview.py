"""JSON preview with folding, expanding, and highlighting in WebKit."""

from __future__ import annotations

from concurrent.futures import ThreadPoolExecutor
from html import escape
from importlib.resources import files
from json import dumps, loads
from typing import Any

from gi.repository import GLib, Gtk
from gi.repository.Gtk import MessageDialog, MessageType
from gi.repository.WebKit2 import LoadEvent, WebView

from jsonpath_ng.exceptions import JsonPathParserError
from jsonpath_ng.ext import parse as json_parse

# --- Extracted JS constants (no more big inline strings) --------------------

JS_EXPAND_HIGHLIGHT = """
const highlights = {highlights};
const expands = {expands};

document.querySelectorAll('.jblock').forEach(
  el => el.classList.add('collapsed')
);

expands.forEach(p => {
  const el = document.querySelector(`[data-jpath="${"{"}p{"}"}"]`);
  if (el) el.classList.remove('collapsed');
});

highlights.forEach(p => {
  const el = document.querySelector(`[data-jpath="${"{"}p{"}"}"]`);
  if (el) el.classList.add('jhighlight');
});
"""

JS_EXPAND_ALL = """
document.querySelectorAll('.jblock').forEach(
  el => el.classList.remove('collapsed')
);
"""

# ---------------------------------------------------------------------------

_EXECUTOR = ThreadPoolExecutor(max_workers=2)


class JSONPreview:
    """Manage JSON parsing, filtering, and rendering.

    Provides a collapsible and highlighted HTML preview.
    """

    def __init__(self, collapse_lines: int = 100) -> None:
        self.collapse_lines = collapse_lines
        self._css: str | None = None
        self._js: str | None = None
        self._json_data: Any = None

        # These are set externally by the caller (e.g., Renderer)
        self.webview: WebView | None = None
        self._win: Gtk.Window | None = None

        self._tab_width = 2
        self.filter_callback = None  # optional callback: (expr, match_count) -> None

    # -------------------------- Public API ---------------------------------

    def to_html(self, text: str, tab_width: int = 2) -> str:
        """Parse JSON text and return the initial full HTML representation.

        The parsed data is stored for later filtering.
        """
        self._json_data = loads(text)
        self._tab_width = tab_width
        return self._generate_html(self._json_data)

    def apply_path_filter(self, expression: str | None) -> None:
        """Filter JSON by JSONPath and update the preview asynchronously.

        A callback is fired with ``(expression, match_count)`` when done.

        ``expression`` may be ``None`` or empty to clear any existing filter
        and fully expand the JSON tree.
        """

        def _task():
            def collect_paths(val, path=""):
                """Collect all JSON paths for expansion when no filter is applied."""
                paths = {path}
                if isinstance(val, dict):
                    for k, v in val.items():
                        new_path = f"{path}.{k}" if path else k
                        paths |= collect_paths(v, new_path)
                elif isinstance(val, list):
                    for i, v in enumerate(val):
                        new_path = f"{path}.[{i}]" if path else f"[{i}]"
                        paths |= collect_paths(v, new_path)
                return paths

            if not expression or not expression.strip():
                expands = collect_paths(self._json_data)
                return self._json_data, [], expands, ""

            try:
                expr = json_parse(expression)
                matches = expr.find(self._json_data)
            except JsonPathParserError:
                # Preserve the original exception type for UI handling
                raise
            except Exception as e:
                # Wrap other exceptions into JsonPathParserError for unified handling
                raise JsonPathParserError("Filter error") from e
            else:
                highlights: list[str] = []
                expands: set[str] = {""}  # Always expand the root
                for m in matches:
                    current = m
                    while current:
                        p = str(current.full_path)
                        if p == "$":
                            p = ""
                        expands.add(p)
                        current = current.context
                    p = str(m.full_path)
                    highlights.append("" if p == "$" else p)
                return self._json_data, highlights, expands, expression

        def _done(fut):
            try:
                data, highlights, expands, expr = fut.result()
            except JsonPathParserError as e:
                GLib.idle_add(self._show_error_dialog, str(e))
                data, highlights, expands, expr = self._json_data, [], {""}, ""

            GLib.idle_add(
                self._render,
                data,
                highlights,
                expands,
                expr,
                len(highlights),
            )

        _EXECUTOR.submit(_task).add_done_callback(_done)

    # -------------------------- Internals ----------------------------------

    def _show_error_dialog(self, message: str) -> bool:
        """Display an error dialog when JSONPath parsing fails."""
        dialog = MessageDialog(
            transient_for=self._win,
            modal=True,
            message_type=MessageType.ERROR,
            buttons=Gtk.ButtonsType.OK,
            text="Invalid JSONPath Expression",
        )
        dialog.format_secondary_text(message)
        dialog.run()
        dialog.destroy()
        return False

    def _generate_html(self, data: Any) -> str:
        """Generate the full HTML document for the given JSON data."""
        pretty = dumps(
            data,
            indent=self._tab_width,
            sort_keys=True,
            ensure_ascii=False,
        )
        line_count = pretty.count("\n") + 1
        collapse = line_count > self.collapse_lines
        body = self._value_to_html(data, collapse, 0, "")
        css, js = self._resources()
        return (
            "<html><head><meta charset='utf-8'>"
            f"<style>{css}</style>"
            "</head><body><pre>"
            + body
            + "</pre>"
            f"<script>{js}</script>"
            "</body></html>"
        )

    def _resources(self) -> tuple[str, str]:
        """Load CSS and JS resources for folding/expanding."""
        if self._css is None or self._js is None:
            data_dir = files("formiko.data")
            self._css = (data_dir / "jsonfold.css").read_text(encoding="utf-8")
            self._js = (data_dir / "jsonfold.js").read_text(encoding="utf-8")
        return self._css, self._js

    def _value_to_html(
        self,
        value: Any,
        collapse: bool,
        level: int,
        path: str,
    ) -> str:
        # Dictionary: use dot notation for child keys, store data-jpath for JSONPath lookup
        if isinstance(value, dict):
            css_classes = ["jblock"]
            if collapse and level > 0:
                css_classes.append("collapsed")
            items = []
            for _key, val in value.items():
                new_path = f"{path}.{_key}" if path else _key
                child_html = self._value_to_html(val, collapse, level + 1, new_path)
                items.append(
                    '<div class="jitem">'
                    '<span class="jkey">'
                    f'"{escape(str(_key))}"'
                    "</span>: "
                    f"{child_html}"
                    "</div>"
                )
            children = "".join(items)
            return (
                f'<div class="{" ".join(css_classes)}" data-jpath="{path}">'
                "<span class='jtoggler'></span>{"
                f"<div class='children'>{children}</div>}}</div>"
            )

        # List: use [i] notation, and dot prefix if not at the root
        if isinstance(value, list):
            css_classes = ["jblock"]
            if collapse and level > 0:
                css_classes.append("collapsed")
            items = []
            for i, v in enumerate(value):
                new_path = f"{path}.[{i}]" if path else f"[{i}]"
                child_html = self._value_to_html(v, collapse, level + 1, new_path)
                items.append('<div class="jitem">' f"{child_html}" "</div>")
            children = "".join(items)
            return (
                f'<div class="{" ".join(css_classes)}" data-jpath="{path}">'
                '<span class="jtoggler"></span>['
                f'<div class="children">{children}</div>]</div>'
            )

        # Primitive values: wrap with a span, assign class by type, and store data-jpath
        if isinstance(value, str):
            esc = escape(value)
            return f'<span class="jstr" data-jpath="{path}">"{esc}"</span>'
        if value is True or value is False:
            val_str = str(value).lower()
            return f'<span class="jbool" data-jpath="{path}">{val_str}</span>'
        if value is None:
            return f'<span class="jnull" data-jpath="{path}">null</span>'
        return f'<span class="jnum" data-jpath="{path}">{value}</span>'

    def _render(
        self,
        data: Any,
        highlights: list[str],
        expands: set[str],
        expr: str,
        count: int,
    ) -> bool:
        """Generate and load HTML, then run JS to fold and highlight."""
        html = self._generate_html(data)

        if not self.webview:
            return False

        # Prevent leftover handlers from triggering multiple times
        if hasattr(self.webview, "highlight_handler_id"):
            self.webview.disconnect(self.webview.highlight_handler_id)

        def on_load_finished(webview: WebView, load_event: LoadEvent):
            if load_event == LoadEvent.FINISHED:
                if expr:
                    js = JS_EXPAND_HIGHLIGHT.format(
                        highlights=dumps(highlights),
                        expands=dumps(list(expands)),
                    )
                    webview.run_javascript(js)
                else:
                    webview.run_javascript(JS_EXPAND_ALL)

                if hasattr(webview, "highlight_handler_id"):
                    webview.disconnect(webview.highlight_handler_id)
                    del webview.highlight_handler_id

        handler_id = self.webview.connect("load-changed", on_load_finished)
        self.webview.highlight_handler_id = handler_id
        self.webview.load_html(html, "file:///")

        if self.filter_callback:
            self.filter_callback(expr, count)

        return False
